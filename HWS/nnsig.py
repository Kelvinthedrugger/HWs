# AUTOGENERATED! DO NOT EDIT! File to edit: 03_NN_numpy.ipynb (unless otherwise specified).

__all__ = ['fetch', 'mnist', 'kaiming_uniform', 'kaiming_normal', 'Linear', 'MSELoss', 'CELoss', 'SGD', 'Adam']

# Cell
import numpy as np

# Cell
def fetch(url):
    import requests, hashlib, os, tempfile
    fp = os.path.join(tempfile.gettempdir(), hashlib.md5(url.encode('utf-8')).hexdigest())

    if os.path.isfile(fp):
        with open(fp, "rb") as f:
            dat = f.read()

    else:
        dat = requests.get(url).content
        with open(fp + ".tmp", "wb") as f:
            f.write(dat)

        os.rename(fp+".tmp", fp)

    return dat

# Cell
def mnist(url1="http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz", url2="http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz", url3="http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz", url4="http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz"):
    # from geohot
    import gzip
    import numpy as np

    def parse(dat): return np.frombuffer(
        gzip.decompress(dat), dtype=np.uint8).copy()

    X_train = parse(fetch(url1))[0x10:].reshape((-1, 28, 28))
    Y_train = parse(fetch(url2))[8:]
    X_test = parse(fetch(url3))[0x10:].reshape((-1, 28, 28))
    Y_test = parse(fetch(url4))[8:]
    return X_train, Y_train, X_test, Y_test


# Cell
# inits
def kaiming_uniform(h,w):
    return np.random.uniform(-1.,1.,size=(h,w))/np.sqrt(2/(h*w))

def kaiming_normal(h,w):
    return

# Cell
class Linear:
    def __init__(self,h,w,init_fn = kaiming_uniform):
        self.weight = init_fn(h,w)
        self.grad = np.zeros((h,w))
        self.fpass = None

    def forward(self,x):
        out = x @ self.weight
        self.fpass = out
        return out

    def backward(self,bpass):
        self.grad = (self.fpass.T) @ bpass
        bpass = bpass @ (self.weight.T)

# Cell
def MSELoss(yhat,y):
    val = np.square(yhat - y).mean(axis=-1)
    grad = 2 * (yhat - y)
    return val, grad

def CELoss(yhat,y):
    """ cross entropy loss"""
    return

# Cell
def SGD(lr = 1e-3, model = None):
    for layer in model:
        layer.weight -= lr * layer.grad

def Adam():
    pass